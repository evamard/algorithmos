<div align="center">
  <img src="./img/Slide1.png">
  <hr />

  <img src="./img/Slide2.png">
  <br/>
  <p >Ο αλγόριθμος του Prim είναι αλγόριθμος γραφημάτων και χρησιμοποιείται, σε συνεκτικά - εμβαρή γραφήματα για την εύρεση ελάχιστων συνδετικών δένδρων. Ο χρόνος εκτέλεσής του ποικίλει, ανάλογα με τον τύπο δεδομένων που θα χρησιμοποιήσουμε κατά την εκτέλεση του αλγορίθμου.</p>
  <hr />

  <img src="./img/Slide3.png">
  <br/>
  <p>Ας τρέξουμε τον αλγόριθμο σε αυτό το γράφημα.</p>
  <hr />

  <img src="./img/Slide4.png">
  <br/>
  <p>Αρχικά, δημιουργούμε μία κενή λίστα, ας την ονομάσουμε <strong><em>T</em></strong>. Αυτή η λίστα θα περιέχει του κόμβους του ελάχιστου συνδετικού δένδρου. Το επόμενο βήμα, είναι να διαλέξουμε έναν τυχαίο κόμβο. Μπορούμε να επιλέξουμε όποιον θέλουμε. Από αυτό τον κόμβο θα ξεκινήσει η εκτέλεση του αλγορίθμου. Ας επιλέξουμε τον <strong><em>a</em></strong>.</p>
  <hr />

  <img src="./img/Slide5.png">
  <br/>
  <p>Εισάγουμε τον <strong><em>a</em></strong> στην λίστα μας.</p>
  <hr />

  <img src="./img/Slide6.png">
  <br/>
  <p>Το επόμενο βήμα, είναι να εξετάσουμε όλες τις ακμές που συνδέονται με τον κόμβο <strong><em>a</em></strong>.</p>
  <hr />

  <img src="./img/Slide7.png">
  <br/>
  <p>Διαλέγουμε την ακμή με το μικρότερο βάρος.</p>
  <hr />

  <img src="./img/Slide8.png">
  <br/>
  <p>Κάθε φορά, η σύνδεση μίας ακμής θα εισάγει έναν καινούριο κόμβο στο ελάχιστο συνδετικό δένδρο, οπότε και θα τον προσθέτουμε στην λίστα <strong><em>T</em></strong>.</p>
  <hr />

  <img src="./img/Slide9.png">
  <br/>
  <p></p>
  <hr />

  <img src="./img/Slide10.png">
  <br/>
  <p>Τώρα εξετάζουμε όλες τις ακμές που συνδέονται με τους κόμβους <strong><em>a</em></strong> και <strong><em>b</em></strong>. Διαλέγουμε και πάλι την ακμή με το μικρότερο βάρος, προσέχοντας να μην συνδέσουμε κόμβους που υπάρχουν ήδη στην λίστα <strong><em>T</em></strong>. Παρατηρήστε ότι προκύπτουν δύο ακμές με ελάχιστο βάρος 8. Σε αυτή την περίπτωση όποια ακμή και να επιλέξουμε δεν θα επηρεάζει την ορθότητα του τελικού αποτελέσματος.</p>
  <hr />

  <img src="./img/Slide11.png">
  <br/>
  <p>Εισάγουμε τον νέο κόμβο στην λίστα μας.</p>
  <hr />

  <img src="./img/Slide12.png">
  <br/>
  <p></p>
  <hr />

  <img src="./img/Slide13.png">
  <br/>
  <p>Παρατηρούμε ότι η αμέσως επόμενη ακμή που συνδέεται με τους κόμβους <strong><em>a</em></strong>, <strong><em>b</em></strong> και <strong><em>c</em></strong> έχει βάρος 2 και συνδέει τους κόμβους <strong><em>c</em></strong> και <strong><em>i</em></strong>. Συνεχίζουμε την ίδια διαδικασία, μέχρι να εισάγουμε όλους τους κόμβους του γραφήματος στην λίστα <strong><em>T</em></strong>.</p>
  <hr />

  <img src="./img/Slide14.png">
  <br/>
  <p></p>
  <hr />

  <img src="./img/Slide15.png">
  <br/>
  <p></p>
  <hr />

  <img src="./img/Slide16.png">
  <br/>
  <p></p>
  <hr />

  <img src="./img/Slide17.png">
  <br/>
  <p></p>
  <hr />

  <img src="./img/Slide18.png">
  <br/>
  <p></p>
  <hr />

  <img src="./img/Slide19.png">
  <br/>
  <p></p>
  <hr />

  <img src="./img/Slide20.png">
  <br/>
  <p></p>
  <hr />

  <img src="./img/Slide21.png">
  <br/>
  <p></p>
  <hr />

  <img src="./img/Slide22.png">
  <br/>
  <p></p>
  <hr />

  <img src="./img/Slide23.png">
  <br/>
  <p></p>
  <hr />

  <img src="./img/Slide24.png">
  <br/>
  <p>Ο αλγόριθμος τερματίζει όταν συνδέσουμε όλους τους κόμβους του γραφήματος μας.</p>
  <hr />

  <img src="./img/Slide25.png">
  <br/>
  <p>Αυτό είναι το ελάχιστο συνδετικό δένδρο που προκύπτει μετά την εκτέλεση του αλγορίθμου.</p>
  <hr />

  <img src="./img/Slide26.png">
  <br/>
  <p>Το συνολικό βάρος του προκύπτει ως άθροισμα από το βάρος όλων των κόμβων του. Στην περίπτωσή μας το συνολικό του βάρος είναι 37, που είναι και το ελάχιστο.</p>
  <hr />

  <img src="./img/Slide27.png">
  <br/>
  <p></p>
  <hr />

  <img src="./img/Slide28.png">
  <br/>
  <p>Αν για παράδειγμα δεν επιλέγαμε την ακμή που συνδέει τους κόμβους <strong><em>b</em></strong> και <strong><em>c</em></strong> αλλά εκείνη που συνδέει τον <strong><em>a</em></strong> με τον <strong><em>h</em></strong>, τότε το ελάχιστο συνδετικό δένδρο θα ήταν διαφορετικό.</p>
  <hr />

  <img src="./img/Slide29.png">
  <br/>
  <p>Όμως θα λάβουμε το ίδιο συνολικό βάρος.</p>
  <hr />

  <img src="./img/Slide30.png">
  <br/>
  <p></p>
  <hr />

  <img src="./img/Slide31.png">
  <br/>
  <p>Στην διαφάνεια μας παρουσιάζεται ο αλγόριθμος του Prim. Ο αλγόριθμος σχετίζεται άμεσα με την διαδικασία που ακολουθήσαμε προηγουμένως. Ας αναλύσουμε τα κύρια σημεία του.</p>
  <hr />

  <img src="./img/Slide32.png">
  <br/>
  <p>Ο αλγόριθμος λαμβάνει τρεις παραμέτρους ως εισόδους. Το γράφημα <strong><em>G</em></strong> όπου θα εφαρμοστεί ο αλγόριθμος, μία συνάρτηση βάρους <strong><em>w</em></strong> όπου αντιστοιχίζεται κάθε ακμή με το αντίστοιχο βάρος της και ο αρχικός κόμβος <strong><em>s</em></strong>. Αρχικά θέτουμε το κόστος όλων των κόμβων με τιμή άπειρο. Ο αρχικός μας κόμβος, λαμβάνει την τιμή 0. Το πεδίο <strong><em>p</em></strong> δηλώνει τον πατρικό ενός κόμβου και θα μας βοηθήσει στο να δημιουργήσουμε το MST.</p>
  <hr />

  <img src="./img/Slide33.png">
  <br/>
  <p>Επόμενο βήμα είναι η δημιουργία της ουράς προτεραιότητας ελαχίστων. Με αυτό τον τρόπο θα μπορούμε να επιλέγουμε κάθε φορά την ακμή με το ελάχιστο βάρος.</p>
  <hr />

  <img src="./img/Slide34.png">
  <br/>
  <p>Ο αλγόριθμος θα πρέπει να συνδέσει όλους τους κόμβους του γραφήματος. Ο βρόγχος while ελέγχει αν υπάρχουν ακόμα κόμβοι στην ουρά <strong><em>Q</em></strong>.</p>
  <hr />

  <img src="./img/Slide35.png">
  <br/>
  <p>Σε κάθε επανάληψη του βρόγχου while εξάγουμε τον κόμβο με το μικρότερο κόστος. Αυτός ο τρόπος διασφαλίζει και την περατότητα του βρόγχου while.</p>
  <hr />

  <img src="./img/Slide36.png">
  <br/>
  <p>Για κάθε κόμβο <strong><em>v</em></strong> που συνδέεται με <strong><em>u</em></strong> και δεν έχει εντοπιστεί, ελέγχουμε αν το κόστος του κόμβου <strong><em>v</em></strong> είναι μεγαλύτερο από το βάρος της ακμή που συνδέει τον <strong><em>u</em></strong> με τον <strong><em>v</em></strong> και τότε ανανεώνουμε το κόστος του <strong><em>d</em></strong> και θέτουμε ως πατρικό του το <strong><em>u</em></strong>.</p>
  <hr />

  <img src="./img/Slide37.png">
  <br/>
  <p></p>
  <hr />

  <img src="./img/Slide38.png">
  <br/>
  <p></p>
  <hr />

  <img src="./img/Slide39.png">
  <br/>
  <p>Οι γραμμές 1 έως 4 έχουνε πολυπλοκότητα <strong><em>O(V)</em></strong> διότι έχουμε έναν επαναληπτικό βρόγχο που εκτελεί τόσες επαναλήψεις, όσες είναι ο αριθμός των κόμβων του γραφήματος.</p>
  <hr />

  <img src="./img/Slide40.png">
  <br/>
  <p>Για την δημιουργία της ουράς προτεραιότητας ελαχίστων απαιτείτε χρόνος <strong><em>O(V)</em></strong> αν υλοποιηθεί με δυαδικό σωρό ή σωρό Fibonacci.</p>
  <hr />

  <img src="./img/Slide41.png">
  <br/>
  <p>Η γραμμή 7 θα εκτελεστεί <strong><em>O(V)</em></strong> φορές, όσες δηλαδή το πλήθος των κόμβων του γραφήμματος.</p>
  <hr />

  <img src="./img/Slide42.png">
  <br/>
  <p>Η εξαγωγή στοιχείου από την ουρά <strong><em>Q</em></strong> απαιτεί συνολικό χρόνο <strong><em>O(V^2)</em></strong> αν υλοποιηθεί με πίνακα, διαφορετικά <strong><em>O(VlogV)</em></strong> αν υλοποιηθεί με δυαδικό σωρό και σωρό Fibonacci.</p>
  <hr />

  <img src="./img/Slide43.png">
  <br/>
  <p>Οι γραμμές 9 έως 12 θα εκτελεστούν συνολικά <strong><em>O(V^2)</em></strong> αν η υλοποίηση του γραφήμματος γίνει με πίνακα γειτνίασης, <strong><em>O(ElogV)</em></strong> αν γίνει με δυαδικό σωρό και <strong><em>O(E + VlogV)</em></strong> αν υλοποιηθεί με σωρό Fibonacci.</p>
  <hr />

  <img src="./img/Slide44.png">
  <br/>
</div>
